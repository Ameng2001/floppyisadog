// Package companyserver comment
// This file was generated by tars2go 1.1.10
// Generated from Company.tars
package companyserver

import (
	"fmt"

	"github.com/TarsCloud/TarsGo/tars/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// Timestamp struct implement
type Timestamp struct {
	Seconds int64 `json:"seconds"`
	Nanos   int32 `json:"nanos"`
}

func (st *Timestamp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Timestamp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Seconds, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Nanos, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Timestamp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Timestamp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Timestamp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Seconds, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Nanos, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Timestamp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CompanyInfo struct implement
type CompanyInfo struct {
	Uuid                    string `json:"uuid"`
	Name                    string `json:"name"`
	Archived                bool   `json:"archived"`
	Default_timezone        string `json:"default_timezone"`
	Default_day_week_starts string `json:"default_day_week_starts"`
}

func (st *CompanyInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CompanyInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Archived, 3, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Default_timezone, 4, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Default_day_week_starts, 5, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CompanyInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CompanyInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CompanyInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 1)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Archived, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Default_timezone, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Default_day_week_starts, 5)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CompanyInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CompanyList struct implement
type CompanyList struct {
	Companies []CompanyInfo `json:"companies"`
	Limit     int32         `json:"limit"`
	Offset    int32         `json:"offset"`
}

func (st *CompanyList) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CompanyList) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Companies = make([]CompanyInfo, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Companies[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = readBuf.ReadInt32(&st.Limit, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Offset, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CompanyList) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CompanyList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CompanyList) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Companies)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Companies {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.Limit, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Offset, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CompanyList) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CompanyListRequest struct implement
type CompanyListRequest struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (st *CompanyListRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CompanyListRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Offset, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Limit, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CompanyListRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CompanyListRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CompanyListRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Offset, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Limit, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CompanyListRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CreateCompanyRequest struct implement
type CreateCompanyRequest struct {
	Name                    string `json:"name"`
	Default_timezone        string `json:"default_timezone"`
	Default_day_week_starts string `json:"default_day_week_starts"`
}

func (st *CreateCompanyRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CreateCompanyRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Name, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Default_timezone, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Default_day_week_starts, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CreateCompanyRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CreateCompanyRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CreateCompanyRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Name, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Default_timezone, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Default_day_week_starts, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CreateCompanyRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCompanyRequest struct implement
type GetCompanyRequest struct {
	Uuid string `json:"uuid"`
}

func (st *GetCompanyRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCompanyRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Uuid, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCompanyRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCompanyRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCompanyRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Uuid, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCompanyRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TeamInfo struct implement
type TeamInfo struct {
	Uuid            string `json:"uuid"`
	Company_uuid    string `json:"company_uuid"`
	Name            string `json:"name"`
	Archived        bool   `json:"archived"`
	Timezone        string `json:"timezone"`
	Day_week_starts string `json:"day_week_starts"`
	Color           string `json:"color"`
}

func (st *TeamInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TeamInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Company_uuid, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Archived, 3, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Timezone, 4, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Day_week_starts, 5, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Color, 6, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TeamInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TeamInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TeamInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Company_uuid, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 2)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Archived, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Timezone, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Day_week_starts, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Color, 6)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *TeamInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TeamList struct implement
type TeamList struct {
	Teams []TeamInfo `json:"teams"`
}

func (st *TeamList) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TeamList) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Teams = make([]TeamInfo, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Teams[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TeamList) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TeamList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TeamList) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Teams)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Teams {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TeamList) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TeamListRequest struct implement
type TeamListRequest struct {
	Company_uuid string `json:"company_uuid"`
}

func (st *TeamListRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TeamListRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TeamListRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TeamListRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TeamListRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *TeamListRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CreateTeamRequest struct implement
type CreateTeamRequest struct {
	Company_uuid    string `json:"company_uuid"`
	Name            string `json:"name"`
	Timezone        string `json:"timezone"`
	Day_week_starts string `json:"day_week_starts"`
	Color           string `json:"color"`
}

func (st *CreateTeamRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CreateTeamRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Timezone, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Day_week_starts, 3, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Color, 4, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CreateTeamRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CreateTeamRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CreateTeamRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Timezone, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Day_week_starts, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Color, 4)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CreateTeamRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetTeamRequest struct implement
type GetTeamRequest struct {
	Company_uuid string `json:"company_uuid"`
	Uuid         string `json:"uuid"`
}

func (st *GetTeamRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetTeamRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Uuid, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetTeamRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetTeamRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetTeamRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Uuid, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetTeamRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// JobInfo struct implement
type JobInfo struct {
	Uuid         string `json:"uuid"`
	Company_uuid string `json:"company_uuid"`
	Team_uuid    string `json:"team_uuid"`
	Name         string `json:"name"`
	Archived     bool   `json:"archived"`
	Color        string `json:"color"`
}

func (st *JobInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *JobInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Company_uuid, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Team_uuid, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 3, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Archived, 4, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Color, 5, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *JobInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require JobInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *JobInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Company_uuid, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Team_uuid, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 3)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Archived, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Color, 5)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *JobInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// JobList struct implement
type JobList struct {
	Jobs []JobInfo `json:"jobs"`
}

func (st *JobList) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *JobList) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Jobs = make([]JobInfo, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Jobs[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *JobList) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require JobList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *JobList) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Jobs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Jobs {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *JobList) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// JobListRequest struct implement
type JobListRequest struct {
	Company_uuid string `json:"company_uuid"`
	Team_uuid    string `json:"team_uuid"`
}

func (st *JobListRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *JobListRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Team_uuid, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *JobListRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require JobListRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *JobListRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Team_uuid, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *JobListRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CreateJobRequest struct implement
type CreateJobRequest struct {
	Company_uuid string `json:"company_uuid"`
	Team_uuid    string `json:"team_uuid"`
	Name         string `json:"name"`
	Color        string `json:"color"`
}

func (st *CreateJobRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CreateJobRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Team_uuid, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Color, 3, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CreateJobRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CreateJobRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CreateJobRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Team_uuid, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Color, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CreateJobRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetJobRequest struct implement
type GetJobRequest struct {
	Uuid         string `json:"uuid"`
	Company_uuid string `json:"company_uuid"`
	Team_uuid    string `json:"team_uuid"`
}

func (st *GetJobRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetJobRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Company_uuid, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Team_uuid, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetJobRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetJobRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetJobRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Company_uuid, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Team_uuid, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetJobRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ShiftInfo struct implement
type ShiftInfo struct {
	Uuid         string    `json:"uuid"`
	Company_uuid string    `json:"company_uuid"`
	Team_uuid    string    `json:"team_uuid"`
	Start        Timestamp `json:"start"`
	Stop         Timestamp `json:"stop"`
	User_uuid    string    `json:"user_uuid"`
	Job_uuid     string    `json:"job_uuid"`
	Published    bool      `json:"published"`
}

func (st *ShiftInfo) ResetDefault() {
	st.Start.ResetDefault()
	st.Stop.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ShiftInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Company_uuid, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Team_uuid, 2, true)
	if err != nil {
		return err
	}

	err = st.Start.ReadBlock(readBuf, 3, true)
	if err != nil {
		return err
	}

	err = st.Stop.ReadBlock(readBuf, 4, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.User_uuid, 5, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Job_uuid, 6, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Published, 7, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ShiftInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ShiftInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ShiftInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Company_uuid, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Team_uuid, 2)
	if err != nil {
		return err
	}

	err = st.Start.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	err = st.Stop.WriteBlock(buf, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.User_uuid, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Job_uuid, 6)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Published, 7)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ShiftInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ShiftList struct implement
type ShiftList struct {
	Shifts             []ShiftInfo `json:"shifts"`
	Shift_start_after  Timestamp   `json:"shift_start_after"`
	Shift_start_before Timestamp   `json:"shift_start_before"`
}

func (st *ShiftList) ResetDefault() {
	st.Shift_start_after.ResetDefault()
	st.Shift_start_before.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ShiftList) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Shifts = make([]ShiftInfo, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Shifts[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = st.Shift_start_after.ReadBlock(readBuf, 1, true)
	if err != nil {
		return err
	}

	err = st.Shift_start_before.ReadBlock(readBuf, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ShiftList) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ShiftList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ShiftList) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Shifts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Shifts {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = st.Shift_start_after.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = st.Shift_start_before.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ShiftList) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ShiftListRequest struct implement
type ShiftListRequest struct {
	Company_uuid       string `json:"company_uuid"`
	Team_uuid          string `json:"team_uuid"`
	User_uuid          string `json:"user_uuid"`
	Job_uuid           string `json:"job_uuid"`
	Shift_start_after  string `json:"shift_start_after"`
	Shift_start_before string `json:"shift_start_before"`
}

func (st *ShiftListRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ShiftListRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Team_uuid, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.User_uuid, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Job_uuid, 3, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Shift_start_after, 4, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Shift_start_before, 5, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ShiftListRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ShiftListRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ShiftListRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Team_uuid, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.User_uuid, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Job_uuid, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Shift_start_after, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Shift_start_before, 5)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ShiftListRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// WorkerShiftListRequest struct implement
type WorkerShiftListRequest struct {
	Company_uuid       string    `json:"company_uuid"`
	Team_uuid          string    `json:"team_uuid"`
	Worker_uuid        string    `json:"worker_uuid"`
	Shift_start_after  Timestamp `json:"shift_start_after"`
	Shift_start_before Timestamp `json:"shift_start_before"`
}

func (st *WorkerShiftListRequest) ResetDefault() {
	st.Shift_start_after.ResetDefault()
	st.Shift_start_before.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *WorkerShiftListRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Team_uuid, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Worker_uuid, 2, true)
	if err != nil {
		return err
	}

	err = st.Shift_start_after.ReadBlock(readBuf, 3, true)
	if err != nil {
		return err
	}

	err = st.Shift_start_before.ReadBlock(readBuf, 4, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *WorkerShiftListRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WorkerShiftListRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *WorkerShiftListRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Team_uuid, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Worker_uuid, 2)
	if err != nil {
		return err
	}

	err = st.Shift_start_after.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	err = st.Shift_start_before.WriteBlock(buf, 4)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *WorkerShiftListRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BulkPublishShiftsRequest struct implement
type BulkPublishShiftsRequest struct {
	Company_uuid       string    `json:"company_uuid"`
	Team_uuid          string    `json:"team_uuid"`
	User_uuid          string    `json:"user_uuid"`
	Job_uuid           string    `json:"job_uuid"`
	Shift_start_after  Timestamp `json:"shift_start_after"`
	Shift_start_before Timestamp `json:"shift_start_before"`
	Published          bool      `json:"published"`
}

func (st *BulkPublishShiftsRequest) ResetDefault() {
	st.Shift_start_after.ResetDefault()
	st.Shift_start_before.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BulkPublishShiftsRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Team_uuid, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.User_uuid, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Job_uuid, 3, true)
	if err != nil {
		return err
	}

	err = st.Shift_start_after.ReadBlock(readBuf, 4, true)
	if err != nil {
		return err
	}

	err = st.Shift_start_before.ReadBlock(readBuf, 5, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Published, 6, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BulkPublishShiftsRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BulkPublishShiftsRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BulkPublishShiftsRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Team_uuid, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.User_uuid, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Job_uuid, 3)
	if err != nil {
		return err
	}

	err = st.Shift_start_after.WriteBlock(buf, 4)
	if err != nil {
		return err
	}

	err = st.Shift_start_before.WriteBlock(buf, 5)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Published, 6)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *BulkPublishShiftsRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CreateShiftRequest struct implement
type CreateShiftRequest struct {
	Company_uuid string    `json:"company_uuid"`
	Team_uuid    string    `json:"team_uuid"`
	Start        Timestamp `json:"start"`
	Stop         Timestamp `json:"stop"`
	User_uuid    string    `json:"user_uuid"`
	Job_uuid     string    `json:"job_uuid"`
	Published    bool      `json:"published"`
}

func (st *CreateShiftRequest) ResetDefault() {
	st.Start.ResetDefault()
	st.Stop.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CreateShiftRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Team_uuid, 1, true)
	if err != nil {
		return err
	}

	err = st.Start.ReadBlock(readBuf, 2, true)
	if err != nil {
		return err
	}

	err = st.Stop.ReadBlock(readBuf, 3, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.User_uuid, 4, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Job_uuid, 5, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Published, 6, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CreateShiftRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CreateShiftRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CreateShiftRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Team_uuid, 1)
	if err != nil {
		return err
	}

	err = st.Start.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	err = st.Stop.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.User_uuid, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Job_uuid, 5)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Published, 6)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CreateShiftRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetShiftRequest struct implement
type GetShiftRequest struct {
	Uuid         string `json:"uuid"`
	Team_uuid    string `json:"team_uuid"`
	Company_uuid string `json:"company_uuid"`
}

func (st *GetShiftRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetShiftRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Team_uuid, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Company_uuid, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetShiftRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetShiftRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetShiftRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Team_uuid, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Company_uuid, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetShiftRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DirectoryEntry struct implement
type DirectoryEntry struct {
	User_uuid            string `json:"user_uuid"`
	Internal_id          string `json:"internal_id"`
	Company_uuid         string `json:"company_uuid"`
	Name                 string `json:"name"`
	Email                string `json:"email"`
	Confirmed_and_active bool   `json:"confirmed_and_active"`
	Phonenumber          string `json:"phonenumber"`
	Photo_url            string `json:"photo_url"`
}

func (st *DirectoryEntry) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DirectoryEntry) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Internal_id, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Company_uuid, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 3, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Email, 4, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Confirmed_and_active, 5, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Phonenumber, 6, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Photo_url, 7, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DirectoryEntry) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DirectoryEntry, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DirectoryEntry) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Internal_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Company_uuid, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Email, 4)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Confirmed_and_active, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Phonenumber, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Photo_url, 7)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DirectoryEntry) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// NewDirectoryEntry struct implement
type NewDirectoryEntry struct {
	Company_uuid string `json:"company_uuid"`
	Name         string `json:"name"`
	Email        string `json:"email"`
	Phonenumber  string `json:"phonenumber"`
	Internal_id  string `json:"internal_id"`
}

func (st *NewDirectoryEntry) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *NewDirectoryEntry) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Email, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Phonenumber, 3, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Internal_id, 4, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *NewDirectoryEntry) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require NewDirectoryEntry, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *NewDirectoryEntry) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Email, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Phonenumber, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Internal_id, 4)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *NewDirectoryEntry) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DirectoryEntryRequest struct implement
type DirectoryEntryRequest struct {
	Company_uuid string `json:"company_uuid"`
	User_uuid    string `json:"user_uuid"`
}

func (st *DirectoryEntryRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DirectoryEntryRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.User_uuid, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DirectoryEntryRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DirectoryEntryRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DirectoryEntryRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.User_uuid, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DirectoryEntryRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DirectoryList struct implement
type DirectoryList struct {
	Accounts []DirectoryEntry `json:"accounts"`
	Limit    int32            `json:"limit"`
	Offset   int32            `json:"offset"`
}

func (st *DirectoryList) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DirectoryList) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Accounts = make([]DirectoryEntry, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Accounts[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = readBuf.ReadInt32(&st.Limit, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Offset, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DirectoryList) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DirectoryList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DirectoryList) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Accounts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Accounts {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.Limit, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Offset, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DirectoryList) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DirectoryListRequest struct implement
type DirectoryListRequest struct {
	Company_uuid string `json:"company_uuid"`
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
}

func (st *DirectoryListRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DirectoryListRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Limit, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Offset, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DirectoryListRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DirectoryListRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DirectoryListRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Limit, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Offset, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DirectoryListRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AdminListRequest struct implement
type AdminListRequest struct {
	Company_uuid string `json:"company_uuid"`
}

func (st *AdminListRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AdminListRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AdminListRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AdminListRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AdminListRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AdminListRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Admins struct implement
type Admins struct {
	Company_uuid string           `json:"company_uuid"`
	Admins       []DirectoryEntry `json:"admins"`
}

func (st *Admins) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Admins) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	_, ty, err = readBuf.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Admins = make([]DirectoryEntry, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Admins[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Admins) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Admins, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Admins) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Admins)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Admins {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *Admins) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AdminOfRequest struct implement
type AdminOfRequest struct {
	User_uuid string `json:"user_uuid"`
}

func (st *AdminOfRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AdminOfRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_uuid, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AdminOfRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AdminOfRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AdminOfRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_uuid, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AdminOfRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AdminOfList struct implement
type AdminOfList struct {
	User_uuid string        `json:"user_uuid"`
	Companies []CompanyInfo `json:"companies"`
}

func (st *AdminOfList) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AdminOfList) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_uuid, 0, true)
	if err != nil {
		return err
	}

	_, ty, err = readBuf.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Companies = make([]CompanyInfo, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Companies[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AdminOfList) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AdminOfList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AdminOfList) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Companies)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Companies {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AdminOfList) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// WorkerListRequest struct implement
type WorkerListRequest struct {
	Company_uuid string `json:"company_uuid"`
	Team_uuid    string `json:"team_uuid"`
}

func (st *WorkerListRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *WorkerListRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Team_uuid, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *WorkerListRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WorkerListRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *WorkerListRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Team_uuid, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *WorkerListRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Workers struct implement
type Workers struct {
	Company_uuid string           `json:"company_uuid"`
	Team_uuid    string           `json:"team_uuid"`
	Workers      []DirectoryEntry `json:"workers"`
}

func (st *Workers) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Workers) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Team_uuid, 1, true)
	if err != nil {
		return err
	}

	_, ty, err = readBuf.SkipToNoCheck(2, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Workers = make([]DirectoryEntry, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Workers[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Workers) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Workers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Workers) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Team_uuid, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Workers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Workers {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *Workers) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Worker struct implement
type Worker struct {
	Company_uuid string `json:"company_uuid"`
	Team_uuid    string `json:"team_uuid"`
	User_uuid    string `json:"user_uuid"`
}

func (st *Worker) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Worker) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Company_uuid, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Team_uuid, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.User_uuid, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Worker) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Worker, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Worker) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Company_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Team_uuid, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.User_uuid, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Worker) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// WorkerOfRequest struct implement
type WorkerOfRequest struct {
	User_uuid string `json:"user_uuid"`
}

func (st *WorkerOfRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *WorkerOfRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_uuid, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *WorkerOfRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WorkerOfRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *WorkerOfRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_uuid, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *WorkerOfRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// WorkerOfList struct implement
type WorkerOfList struct {
	User_uuid string     `json:"user_uuid"`
	Teams     []TeamInfo `json:"teams"`
}

func (st *WorkerOfList) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *WorkerOfList) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_uuid, 0, true)
	if err != nil {
		return err
	}

	_, ty, err = readBuf.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Teams = make([]TeamInfo, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Teams[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *WorkerOfList) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WorkerOfList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *WorkerOfList) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_uuid, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Teams)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Teams {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *WorkerOfList) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Association struct implement
type Association struct {
	Account DirectoryEntry `json:"account"`
	Teams   []TeamInfo     `json:"teams"`
	Admin   bool           `json:"admin"`
}

func (st *Association) ResetDefault() {
	st.Account.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Association) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Account.ReadBlock(readBuf, 0, true)
	if err != nil {
		return err
	}

	_, ty, err = readBuf.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Teams = make([]TeamInfo, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Teams[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = readBuf.ReadBool(&st.Admin, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Association) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Association, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Association) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Account.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Teams)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Teams {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteBool(st.Admin, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Association) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AssociationList struct implement
type AssociationList struct {
	Accounts []Association `json:"accounts"`
	Limit    int32         `json:"limit"`
	Offset   int32         `json:"offset"`
}

func (st *AssociationList) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AssociationList) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Accounts = make([]Association, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Accounts[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	err = readBuf.ReadInt32(&st.Limit, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Offset, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AssociationList) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AssociationList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AssociationList) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Accounts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Accounts {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.Limit, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Offset, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AssociationList) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TimeZoneList struct implement
type TimeZoneList struct {
	Timezones []string `json:"timezones"`
}

func (st *TimeZoneList) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TimeZoneList) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Timezones = make([]string, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = readBuf.ReadString(&st.Timezones[i0], 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TimeZoneList) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TimeZoneList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TimeZoneList) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Timezones)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Timezones {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TimeZoneList) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ScheduledPerWeek struct implement
type ScheduledPerWeek struct {
	Week  string `json:"week"`
	Count int32  `json:"count"`
}

func (st *ScheduledPerWeek) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ScheduledPerWeek) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Week, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Count, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ScheduledPerWeek) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ScheduledPerWeek, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ScheduledPerWeek) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Week, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Count, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ScheduledPerWeek) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GrowthGraphResponse struct implement
type GrowthGraphResponse struct {
	People_scheduled_per_week map[string]int32 `json:"people_scheduled_per_week"`
	People_on_shifts          int32            `json:"people_on_shifts"`
}

func (st *GrowthGraphResponse) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GrowthGraphResponse) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, err = readBuf.SkipTo(codec.MAP, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&length, 0, true)
	if err != nil {
		return err
	}

	st.People_scheduled_per_week = make(map[string]int32)
	for i0, e0 := int32(0), length; i0 < e0; i0++ {
		var k0 string
		var v0 int32

		err = readBuf.ReadString(&k0, 0, false)
		if err != nil {
			return err
		}

		err = readBuf.ReadInt32(&v0, 1, false)
		if err != nil {
			return err
		}

		st.People_scheduled_per_week[k0] = v0
	}

	err = readBuf.ReadInt32(&st.People_on_shifts, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GrowthGraphResponse) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GrowthGraphResponse, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GrowthGraphResponse) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.People_scheduled_per_week)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.People_scheduled_per_week {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteInt32(v1, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.People_on_shifts, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GrowthGraphResponse) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}
